{"version":3,"file":"youtube.js","sources":["../../src/embed/youtube.js"],"sourcesContent":["// IframeTube - all rights reserved.\r\n// copyright (c) 2026\r\n// you may copy this project and modify it for personal use only.\r\n// you may not distribute this project or any modified versions of it without explicit permission from the author.\r\n\r\n// view the full source code and how this works here: https://github.com/IframeTube/IframeTube\r\n// if you encounter any issues, please report them here: https://github.com/IframeTube/IframeTube/issues\r\n\r\n\r\n// wraps everything inside an IIFE (this avoids some edge cases)\r\n(function () {\r\n    'use strict'; // better for debugging\r\n\r\n    /*\r\n    -------------- IframeTube helper functions ----------------------------\r\n    */\r\n\r\n    // sets a cookie\r\n    function IframeTube_setCookie(name, value) {\r\n        document.cookie = name + \"=\" + (value) + \"; path=/\";\r\n    }\r\n\r\n    // reads a cookie\r\n    function IframeTube_readCookie(name) {\r\n        let nameEQ = name + \"=\";\r\n        let cookies = document.cookie.split(';').map(c => c.trimStart());\r\n\r\n        for (let cookie of cookies) {\r\n            if (cookie.startsWith(nameEQ)) {\r\n                return cookie.substring(nameEQ.length);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // extracts the parameters from the YouTube watch URL (e.g. videoID)\r\n    function IframeTube_extractParams(param) {\r\n        if (IframeTube_watchPage()) {\r\n            let url = window.location.href;\r\n            let params = {};\r\n\r\n            if (url.indexOf('/watch?') !== -1) {\r\n                let queryString = url.split('?')[1];\r\n                let queryParts = queryString.split('&');\r\n                for (let i = 0; i < queryParts.length; i++) {\r\n                    let keyValue = queryParts[i].split('=');\r\n                    params[decodeURIComponent(keyValue[0])] = decodeURIComponent(keyValue[1]);\r\n                }\r\n            }\r\n            // some video URLS are /watch/VIDEOID or /live/VIDEOID\r\n            else if (url.indexOf('/watch/') !== -1 || url.indexOf('/live/') !== -1) {\r\n                let pathParts = url.split('/');\r\n                params['v'] = pathParts[pathParts.length - 1].split('?')[0];\r\n            }\r\n\r\n            return params[param]\r\n        }\r\n    }\r\n\r\n    // checks if we are on a YouTube watch page\r\n    function IframeTube_watchPage() {\r\n\r\n        // the watch pages are watch? /watch/ or /live/\r\n        if (window.location.href.indexOf('/watch?') !== -1 || window.location.href.indexOf('/watch/') !== -1 || window.location.href.indexOf('/live/') !== -1) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // checks if we are on a YouTube shorts watch page\r\n    function IframeTube_shortsWatchPage() {\r\n\r\n        if (window.location.href.indexOf('/shorts/') !== -1) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // checks if the entered URL is a watch URL\r\n    function IframeTube_isWatchUrl(url) {\r\n\r\n        return (\r\n            url.indexOf('/watch?') !== -1 ||\r\n            url.indexOf('/watch/') !== -1 ||\r\n            url.indexOf('/live/') !== -1\r\n        );\r\n    }\r\n\r\n    // checks if we are watching an ad\r\n    function IframeTube_WatchingAd() {\r\n        if (IframeTube_watchPage()) {\r\n\r\n            // checks for the ad elements (these two elements are the most reliable indicators)\r\n            let adElement = document.querySelector('.video-ads');\r\n            let adPlaying = document.querySelector('.ad-showing');\r\n            // if either of them exists and is visible, we are watching an ad\r\n            if (adElement && adElement.checkVisibility() || adPlaying && adPlaying.checkVisibility()) {\r\n                return true;\r\n            }\r\n            // otherwise, we are not watching an ad\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // triggers a shortcut programmatically\r\n    function IframeTube_shortcut(key) {\r\n        let actualKey = '';\r\n        let code = '';\r\n        let shift = false;\r\n        let keyCode = 0;\r\n        let which = 0;\r\n\r\n        // theatrer mode\r\n        if (key === 't') {\r\n            actualKey = 't';\r\n            code = 'KeyT';\r\n            shift = false;\r\n            keyCode = 84;\r\n            which = 84;\r\n        }\r\n\r\n        // next video (we do not use the API, as it causes issues with ADS)\r\n        else if (key === 'next') {\r\n            actualKey = 'n';\r\n            code = 'KeyN';\r\n            shift = true;\r\n            keyCode = 78;\r\n            which = 78;\r\n        }\r\n\r\n        // previous video (we do not use the API, as it causes issues with ADS)\r\n        else if (key === 'previous') {\r\n            actualKey = 'p';\r\n            code = 'KeyP';\r\n            shift = true;\r\n            keyCode = 80;\r\n            which = 80;\r\n        }\r\n\r\n        // dispatch the events (we dispatch all of these to make it faster and reliable)\r\n        let focusEvent = new Event('focus', { bubbles: true, cancelable: true });\r\n        document.body.dispatchEvent(focusEvent);\r\n\r\n        let keydownEvent = new KeyboardEvent('keydown', {\r\n            key: actualKey,\r\n            code: code,\r\n            shiftKey: shift,\r\n            keyCode: keyCode,\r\n            which: which,\r\n            bubbles: true,\r\n            cancelable: true,\r\n        });\r\n        document.body.dispatchEvent(keydownEvent);\r\n\r\n        let beforeInputEvent = new InputEvent('beforeinput', {\r\n            inputType: 'insertText',\r\n            data: actualKey,\r\n            bubbles: true,\r\n            cancelable: true,\r\n        });\r\n        document.body.dispatchEvent(beforeInputEvent);\r\n\r\n        let keypressEvent = new KeyboardEvent('keypress', {\r\n            key: actualKey,\r\n            code: code,\r\n            shiftKey: shift,\r\n            keyCode: keyCode,\r\n            which: which,\r\n            bubbles: true,\r\n            cancelable: true,\r\n        });\r\n        document.body.dispatchEvent(keypressEvent);\r\n\r\n        let inputEvent = new InputEvent('input', {\r\n            inputType: 'insertText',\r\n            data: actualKey,\r\n            bubbles: true,\r\n            cancelable: true,\r\n        });\r\n        document.body.dispatchEvent(inputEvent);\r\n\r\n        let changeEvent = new Event('change', { bubbles: true, cancelable: true });\r\n        document.body.dispatchEvent(changeEvent);\r\n\r\n        let keyupEvent = new KeyboardEvent('keyup', {\r\n            key: actualKey,\r\n            code: code,\r\n            shiftKey: shift,\r\n            keyCode: keyCode,\r\n            which: which,\r\n            bubbles: true,\r\n            cancelable: true,\r\n        });\r\n        document.body.dispatchEvent(keyupEvent);\r\n    }\r\n\r\n    /*\r\n    -------------- IframeTube global variables ----------------------------\r\n    */\r\n\r\n    // proxy iframe (the raw iframe element)\r\n    let IframeTube_proxyPlayer = false;\r\n\r\n    // the wrapper div around the proxy iframe (used for positioning)\r\n    let IframeTube_proxyWrapper = false;\r\n\r\n    // pip indicator\r\n    let IframeTube_pip = false;\r\n\r\n    // indicates if the proxy iframe has loaded\r\n    let IframeTube_proxyLoaded = false;\r\n\r\n    // indicates if the YouTube embedded iframe INSIDE the proxy iframe has loaded\r\n    let IframeTube_youtubePlayerLoaded = false;\r\n\r\n    // iframe API reference\r\n    let IframeTube_iframe_api = false;\r\n\r\n    // shorts API reference\r\n    let IframeTube_shorts_api = false;\r\n\r\n    // indicates if the quality listener for the main player has been added\r\n    let IframeTube_qualityListenerAdded = false;\r\n\r\n    // last URL tracker\r\n    let IframeTube_lastURL = false;\r\n\r\n    // last video ID tracker\r\n    let IframeTube_lastVideoId = false;\r\n\r\n    // this indicates if the user used the back/forward buttons (browser navigation)\r\n    let IframeTube_historyPopped = false;\r\n\r\n    // indicates if a video has been embedded yet (we load other videos via the iframe API)\r\n    let IframeTube_embeddedVideo = false;\r\n\r\n    // indicates if we are currently syncing the main player with the embedded one\r\n    let IframeTube_syncing = false;\r\n\r\n    // playlist indicator\r\n    let IframeTube_playlist = false;\r\n\r\n    // we use a cookie to store the autoplay state (also persists after a page reload)\r\n    let IframeTube_autoPlay = IframeTube_readCookie('IframeTube_autoplay')\r\n    if (!IframeTube_autoPlay) {\r\n        IframeTube_autoPlay = 'true';\r\n        IframeTube_setCookie('IframeTube_autoplay', IframeTube_autoPlay);\r\n    }\r\n\r\n    /*\r\n    -------------- Youtube page functions ----------------------------\r\n    */\r\n\r\n    // hides ads and other unwanted elements on the page\r\n    function IframeTube_hidePageAdsEtc() {\r\n        let style = document.createElement('style')\r\n\r\n        style.textContent = `\r\n    \r\n    /* we use this class to hide elements via JS */\r\n    .IframeTube_hidden {\r\n        display: none !important;\r\n    }\r\n\r\n    /* hides the miniplayer */\r\n    ytd-miniplayer {\r\n        display: none !important;\r\n    }\r\n\r\n    /* hides the native player, but not the shorts player */\r\n    #player-full-bleed-container,\r\n    #player:not(.ytd-shorts) {\r\n        visibility: hidden !important;\r\n    }\r\n\r\n    /* hides the channel player (not supported yet, sorry yall) */\r\n    ytd-channel-video-player-renderer {\r\n        display: none !important;\r\n    }\r\n\r\n    /* hides page ads (this was taken from: https://greasyfork.org/ru/scripts/447802-youtube-web-tweaks/code, huge thanks to xX_LegendCraftd_Xx :) */\r\n    .ytd-search ytd-shelf-renderer,\r\n    ytd-reel-shelf-renderer,\r\n    ytd-merch-shelf-renderer,\r\n    ytd-action-companion-ad-renderer,\r\n    ytd-display-ad-renderer,\r\n    ytd-rich-section-renderer,\r\n    ytd-video-masthead-ad-advertiser-info-renderer,\r\n    ytd-video-masthead-ad-primary-video-renderer,\r\n    ytd-in-feed-ad-layout-renderer,\r\n    ytd-ad-slot-renderer,\r\n    ytd-statement-banner-renderer,\r\n    ytd-banner-promo-renderer-background ytd-ad-slot-renderer,\r\n    ytd-in-feed-ad-layout-renderer,\r\n    .ytwPanelAdHeaderImageLockupViewModelHost,\r\n    ytd-ads-engagement-panel-content-renderer,\r\n    #content.ytd-ads-engagement-panel-content-renderer,\r\n    ytd-engagement-panel-section-list-renderer[target-id=\"engagement-panel-ads\"],\r\n    ytd-rich-item-renderer:has(> #content > ytd-ad-slot-renderer),\r\n    .ytd-video-masthead-ad-v3-renderer,\r\n    div#root.style-scope.ytd-display-ad-renderer.yt-simple-endpoint,\r\n    div#sparkles-container.style-scope.ytd-promoted-sparkles-web-renderer,\r\n    div#main-container.style-scope.ytd-promoted-video-renderer,\r\n    div#player-ads.style-scope.ytd-watch-flexy,\r\n    #clarify-box,\r\n    ytm-rich-shelf-renderer,\r\n    ytm-search ytm-shelf-renderer,\r\n    ytm-button-renderer.icon-avatar_logged_out,\r\n    ytm-companion-slot,\r\n    ytm-reel-shelf-renderer,\r\n    ytm-merch-shelf-renderer,\r\n    ytm-action-companion-ad-renderer,\r\n    ytm-display-ad-renderer,\r\n    ytm-rich-section-renderer,\r\n    ytm-video-masthead-ad-advertiser-info-renderer,\r\n    ytm-video-masthead-ad-primary-video-renderer,\r\n    ytm-in-feed-ad-layout-renderer,\r\n    ytm-ad-slot-renderer,\r\n    ytm-statement-banner-renderer,\r\n    ytm-banner-promo-renderer-background ytm-ad-slot-renderer,\r\n    ytm-in-feed-ad-layout-renderer,\r\n    ytm-rich-item-renderer:has(> #content > ytm-ad-slot-renderer) .ytm-video-masthead-ad-v3-renderer,\r\n    div#root.style-scope.ytm-display-ad-renderer.yt-simple-endpoint,\r\n    div#sparkles-container.style-scope.ytm-promoted-sparkles-web-renderer,\r\n    div#main-container.style-scope.ytm-promoted-video-renderer,\r\n    div#player-ads.style-scope.ytm-watch-flexy,\r\n    ytm-pivot-bar-item-renderer:has(> .pivot-shorts),\r\n    ytd-compact-movie-renderer,\r\n    yt-about-this-ad-renderer,\r\n    masthead-ad,\r\n    ad-slot-renderer,\r\n    yt-mealbar-promo-renderer,\r\n    statement-banner-style-type-compact,\r\n    ytm-promoted-sparkles-web-renderer,\r\n    tp-yt-iron-overlay-backdrop,\r\n    #masthead-ad {\r\n    display: none !important;\r\n    }\r\n\r\n    .style-scope[page-subtype=\"channels\"] ytd-shelf-renderer,\r\n    .style-scope[page-subtype=\"channels\"] ytm-shelf-renderer {\r\n        display: block !important;\r\n    }\r\n    `;\r\n        // append the styles\r\n        document.head.appendChild(style);\r\n    }\r\n\r\n    // mutes and pauses all videos on the page (e.g. the main YouTube player)\r\n    function IframeTube_muteAndPauseVideos() {\r\n        // only run on watch pages\r\n        if (!IframeTube_watchPage()) {\r\n            return;\r\n        }\r\n\r\n        // get all videos on the page\r\n        let videos = document.querySelectorAll('video');\r\n        videos.forEach((video) => {\r\n            // mute and pause if not already muted/paused and not watching an ad and not syncing when on the main player\r\n            if ((!video.paused || !video.muted || video.volume !== 0) && !IframeTube_WatchingAd() && (!IframeTube_syncing || !video.closest('#movie_player'))) {\r\n                video.muted = true;\r\n                video.volume = 0;\r\n                video.pause();\r\n            }\r\n\r\n            // unmute and play if muted/paused and watching an ad\r\n            else if ((!video.muted || video.volume !== 0 || video.paused) && IframeTube_WatchingAd()) {\r\n                video.muted = true;\r\n                video.volume = 0;\r\n                video.play();\r\n            }\r\n        });\r\n    }\r\n\r\n    // you are welcome to open a pull request or an issue on Github if you find a reliable way to support the miniplayer\r\n    // mutes the miniplayer (miniplayer is not supported with IframeTube, sorry yall)\r\n    function IframeTube_mute_miniplayer() {\r\n        let miniplayer = document.querySelector('ytd-miniplayer');\r\n        if (miniplayer) {\r\n            let video = miniplayer.querySelector('video');\r\n            if (video && (!video.paused || !video.muted || video.volume !== 0)) {\r\n                video.muted = true;\r\n                video.volume = 0;\r\n                video.pause();\r\n            }\r\n        }\r\n    }\r\n\r\n    // creates the proxy iframe\r\n    let IframeTube_proxyIframe_timeout = false;\r\n    function IframeTube_proxyIframe() {\r\n        // retry if the body does not exist yet\r\n        if (!document.body) {\r\n            clearTimeout(IframeTube_proxyIframe_timeout);\r\n            IframeTube_proxyIframe_timeout = setTimeout(IframeTube_proxyIframe, 100);\r\n            return;\r\n        }\r\n\r\n        // creates a wrapper which is going to be used for positioning\r\n        let proxyWrapper = document.createElement('div');\r\n        proxyWrapper.id = 'IframeTube_proxyWrapper';\r\n        // hides it first\r\n        proxyWrapper.classList.add('IframeTube_hidden');\r\n        document.body.appendChild(proxyWrapper);\r\n\r\n        // expose it globally\r\n        IframeTube_proxyWrapper = proxyWrapper;\r\n\r\n        // apply custom styles to the proxy wrapper\r\n        let style = document.createElement('style');\r\n        style.textContent = `\r\n        /* IframeTube Proxy Iframe Styles */\r\n        #IframeTube_proxyWrapper {\r\n            border-radius: 12px; /* rounded corners */\r\n            background: transparent;\r\n            position: absolute; /* we position it absolutely */\r\n            top: 0;\r\n            left: 0;\r\n            z-index: 999;\r\n            overflow: hidden; /* hides anything that slips out of bounds */\r\n        }\r\n\r\n        /* hide the iframe on home page when in PIP to keep the PIP player still playing */\r\n        #IframeTube_proxyWrapper.PIP {\r\n            position: fixed;\r\n            width: 1px;\r\n            height: 1px;\r\n            opacity: 0;\r\n            pointer-events: none;\r\n            left: -9999px;\r\n            top: -9999px;\r\n            overflow: hidden;\r\n        }\r\n\r\n    `;\r\n        // append the styles\r\n        document.head.appendChild(style);\r\n\r\n        // creates the proxy iframe\r\n        let proxy = document.createElement('iframe');\r\n        proxy.src = 'https://example.net/?IframeTubeProxy=1'; // the param (?IframeTubeProxy=1) is an indicator that this is OUR proxy URL\r\n        proxy.setAttribute('allow', 'autoplay *; picture-in-picture *; web-share *; gyroscope *; accelerometer *; clipboard-write *; encrypted-media *;'); // allows everything needed for a Youtube video\r\n        proxy.setAttribute('referrerpolicy', 'strict-origin-when-cross-origin'); // set a strict referrer policy\r\n        proxy.setAttribute('width', '100%');\r\n        proxy.setAttribute('height', '100%');\r\n        proxy.setAttribute('frameborder', '0'); // no border\r\n        proxy.setAttribute('scrolling', 'yes');\r\n        proxy.setAttribute('allowfullscreen', 'true');\r\n        proxy.setAttribute('style', 'display: none;'); // hide for now\r\n        proxyWrapper.appendChild(proxy);\r\n\r\n        // expose it globablly\r\n        IframeTube_proxyPlayer = proxy;\r\n\r\n        // starts the repeater function (this needs to run every 100ms to catch URL changes)\r\n        IframeTube_repeater();\r\n        setInterval(IframeTube_repeater, 100);\r\n    }\r\n\r\n    // position the iframe proxy over the native player (exact size and position)\r\n    function IframeTube_positionProxy() {\r\n        // sanity check to make sure we are on a watch page\r\n        if (IframeTube_watchPage()) {\r\n            // get the known native player elements\r\n            let players = [\r\n                '#player.ytd-watch-flexy',\r\n                '.player-size',\r\n                '#ytd-player',\r\n                '.html5-video-player'\r\n            ];\r\n\r\n            // loop through them until we find one that exists and is visible\r\n            let nativePlayer = false;\r\n            for (let i = 0; i < players.length; i++) {\r\n                nativePlayer = document.querySelector(players[i]);\r\n                if (nativePlayer && nativePlayer.offsetWidth > 0) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // position the proxy over the native player (sanity check to make sure it exists and is visible)\r\n            if (nativePlayer && nativePlayer.offsetWidth > 0) {\r\n                // get the position and size of the native player\r\n                let rect = nativePlayer.getBoundingClientRect();\r\n                // set the size and position of the proxy wrapper to match the native player (take window scroll into account)\r\n                IframeTube_proxyWrapper.style.width = rect.width + 'px';\r\n                IframeTube_proxyWrapper.style.height = rect.height + 'px';\r\n                IframeTube_proxyWrapper.style.top = (window.scrollY + rect.top) + 'px';\r\n                IframeTube_proxyWrapper.style.left = (window.scrollX + rect.left) + 'px';\r\n\r\n                // if the player was in PIP mode, make sure we remove it (sanity check)\r\n                if (IframeTube_proxyWrapper.classList.contains('PIP')) {\r\n                    IframeTube_proxyWrapper.classList.remove('PIP');\r\n                }\r\n\r\n                // show the proxy wrapper class\r\n                IframeTube_proxyWrapper.classList.remove('IframeTube_hidden');\r\n            }\r\n        }\r\n    }\r\n\r\n    // embeds the video into the proxy iframe\r\n    let IframeTube_embedVideo_timeout = false;\r\n    function IframeTube_embedVideo() {\r\n        // if the proxy is not loaded, retry until it is\r\n        if (!IframeTube_proxyLoaded) {\r\n            clearTimeout(IframeTube_embedVideo_timeout);\r\n            IframeTube_embedVideo_timeout = setTimeout(IframeTube_embedVideo, 100);\r\n            return;\r\n        }\r\n\r\n        // gets the current video ID from the URL\r\n        let videoId = IframeTube_extractParams('v');\r\n\r\n        // checks if we are on a playlist\r\n        let playList = IframeTube_extractParams('list');\r\n        // if we are on a playlist\r\n        if (playList) {\r\n            // set the playlist indicator to true\r\n            IframeTube_playlist = true;\r\n            // enable the previous button in the proxy player\r\n            IframeTube_player_enablePrevButton();\r\n        }\r\n\r\n        // else, we are not on a playlist\r\n        else {\r\n            // set the playlist indicator to false\r\n            IframeTube_playlist = false;\r\n            // disable the previous button in the proxy player\r\n            IframeTube_player_disablePrevButton();\r\n        }\r\n\r\n        // get the start param from the URL\r\n        let startTimeNumber = 0\r\n        let tParam = IframeTube_extractParams('t');\r\n        // if it exists, remove the 's' at the end and set the start time number\r\n        if (tParam) {\r\n            startTimeNumber = tParam.replace('s', '');\r\n        }\r\n\r\n        // if the start time number is bigger than 0, set the start time param to it\r\n        // we do this to safely embed the url even if the start time is 0\r\n        let startTime = '';\r\n        if (startTimeNumber > 0) {\r\n            startTime = '&start=' + startTimeNumber;\r\n        }\r\n\r\n        // gets the language of the page (the embedded player is set to your language to make it more comfortable)\r\n        let ytLang = document.documentElement.lang\r\n\r\n        // extracts the language code (e.g. en from en-US)\r\n        let IframeTube_language = ytLang.split(\"-\")[0].toLowerCase();\r\n\r\n        // if we did not embed a video yet, embed it now\r\n        if (!IframeTube_embeddedVideo) {\r\n\r\n            // copy the autoplay attribute only once on the first video embed\r\n            IframeTube_copyAutoPlayAttribute();\r\n\r\n            // the ?IframeTubeEmbed=1 param is an indicator that this is our embed URL\r\n            // we use autoplay=1 to make sure the video autoplays and IframeTube_autoPlay to control the autoplay’s button state, for the language we use the hl param and also set the start time if it exists\r\n            // send the embed url to the proxy iframe\r\n            IframeTube_proxyPlayer.contentWindow.postMessage(\r\n                'IframeTube_embedVideo_https://www.youtube.com/embed/' + videoId + '?IframeTubeEmbed=1&autoplay=1&IframeTube_autoPlay=' + IframeTube_autoPlay + '&hl=' + IframeTube_language + startTime,\r\n                '*'\r\n            );\r\n            // set the indicator to true, as we have now embedded a video\r\n            IframeTube_embeddedVideo = true;\r\n        }\r\n        // for all other cases, do NOT reload the iframe, just load a new video via the iframe API\r\n        else {\r\n            // sends the load video message with the video ID and start time\r\n            IframeTube_proxyPlayer.contentWindow.postMessage(\r\n                'IframeTube_api_' + videoId + '|' + startTime,\r\n                '*'\r\n            );\r\n        }\r\n\r\n        // if there is no start time param, try to sync the Youtube main’s player start time\r\n        // sometimes even though the 't' param is 0 or does not exist, Youtube synces to the last time you left the video\r\n        if (startTimeNumber <= 0) {\r\n            IframeTube_syncStart();\r\n        }\r\n    }\r\n\r\n    // syncs the start time of the main Youtube player to the embedded one (if there is not t param)\r\n    let IframeTube_syncStart_timeout = false;\r\n    function IframeTube_syncStart() {\r\n        // fetch the iframe api\r\n        IframeTube_iframe_api = document.getElementById('movie_player')\r\n\r\n        // make sure it exists and getCurrentTime is available\r\n        if (IframeTube_iframe_api && IframeTube_iframe_api.getCurrentTime) {\r\n            let currentTime = IframeTube_iframe_api.getCurrentTime();\r\n            // if it’s bigger than 0\r\n            if (currentTime > 0) {\r\n                // call the function to sync the start time\r\n                IframeTube_player_seekTo(currentTime);\r\n            }\r\n        }\r\n\r\n        // otherwise, retry in 100ms until it is available\r\n        else {\r\n            clearTimeout(IframeTube_syncStart_timeout);\r\n            IframeTube_syncStart_timeout = setTimeout(IframeTube_syncStart, 100);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // sets the lowest available quality on the main Youtube player (this helps to reduce internet usage and performance impact)\r\n    let IframeTube_setLowestQuality_timeout = false;\r\n    function IframeTube_setLowestQuality() {\r\n\r\n        // refetch the iframe api\r\n        IframeTube_iframe_api = document.getElementById('movie_player')\r\n\r\n        // make sure all the quality functions are available\r\n        if (IframeTube_iframe_api && IframeTube_iframe_api.setPlaybackQualityRange && IframeTube_iframe_api.getAvailableQualityLevels && IframeTube_iframe_api.getPlaybackQuality) {\r\n\r\n            // get the available qualities and then the lowest one (second last in the array, as the last one is 'auto')\r\n            let availableQualities = IframeTube_iframe_api.getAvailableQualityLevels();\r\n            let lowestQuality = availableQualities[availableQualities.length - 2];\r\n\r\n            // set the playback quality range (this is needed to force the quality, as setPlaybackQuality was removed)\r\n            IframeTube_iframe_api.setPlaybackQualityRange(lowestQuality, lowestQuality);\r\n\r\n            // if we did not add the listener yet, add it now\r\n            if (!IframeTube_qualityListenerAdded) {\r\n                // whenever Youtube somehow changes the quality on the main player, immediately set it back to the lowest quality\r\n                IframeTube_iframe_api.addEventListener('onPlaybackQualityChange', IframeTube_setLowestQuality);\r\n                // set the indicator to true\r\n                IframeTube_qualityListenerAdded = true;\r\n            }\r\n        }\r\n        // if the api is not available yet, retry\r\n        else {\r\n            clearTimeout(IframeTube_setLowestQuality_timeout);\r\n            IframeTube_setLowestQuality_timeout = setTimeout(IframeTube_setLowestQuality, 100);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // the shorts player quality is synced with the main player, so we need to fix it for shorts pages\r\n    let IframeTube_fixShortsQuality_timeout = false;\r\n    function IframeTube_fixShortsQuality() {\r\n\r\n        // if we are not on a shorts watch page\r\n        if (IframeTube_shortsWatchPage()) {\r\n            // get the shorts player api\r\n            IframeTube_shorts_api = document.getElementById('shorts-player');\r\n            if (!IframeTube_shorts_api) {\r\n                clearTimeout(IframeTube_fixShortsQuality_timeout);\r\n                IframeTube_fixShortsQuality_timeout = setTimeout(IframeTube_fixShortsQuality, 100);\r\n                return;\r\n            }\r\n\r\n            // make sure all the quality functions are available\r\n            if (IframeTube_shorts_api && IframeTube_shorts_api.setPlaybackQualityRange && IframeTube_shorts_api.getAvailableQualityLevels) {\r\n\r\n                // get all of the available qualities, and select the highest (usually HD)\r\n                let availableQualities = IframeTube_shorts_api.getAvailableQualityLevels();\r\n                let highestQuality = availableQualities[0];\r\n\r\n                // set the playback quality range to the highest quality\r\n                IframeTube_shorts_api.setPlaybackQualityRange(highestQuality, highestQuality);\r\n\r\n                // if the listener for quality has been added, reload the page (this is the only reliable way, as the shorts api is buggy)\r\n                if (IframeTube_qualityListenerAdded) {\r\n                    location.reload();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // stop the embedded player’s playback\r\n    let IframeTube_player_stop_timeout = false;\r\n    function IframeTube_player_stop() {\r\n        // if the embedded player is not loaded yet, retry\r\n        if (!IframeTube_youtubePlayerLoaded) {\r\n            clearTimeout(IframeTube_player_stop_timeout);\r\n            IframeTube_player_stop_timeout = setTimeout(IframeTube_player_stop, 100);\r\n            return;\r\n        }\r\n\r\n        // send the stop playback message to the embedded player\r\n        IframeTube_proxyPlayer.contentWindow.postMessage('IframeTube_stopPlayback', '*');\r\n    }\r\n\r\n    // resumes the embedded player’s playback (currently unused)\r\n    let IframeTube_player_resume_timeout = false;\r\n    function IframeTube_player_resume() {\r\n        if (!IframeTube_youtubePlayerLoaded) {\r\n            clearTimeout(IframeTube_player_resume_timeout);\r\n            IframeTube_player_resume_timeout = setTimeout(IframeTube_player_resume, 100);\r\n            return;\r\n        }\r\n\r\n        IframeTube_proxyPlayer.contentWindow.postMessage('IframeTube_resumePlayback', '*');\r\n    }\r\n\r\n    // seeks the embedded player to a specific time\r\n    let IframeTube_player_seekTo_timeout = false;\r\n    function IframeTube_player_seekTo(time) {\r\n        // if the embedded player is not loaded yet, retry in 100ms until it is\r\n        if (!IframeTube_youtubePlayerLoaded) {\r\n            clearTimeout(IframeTube_player_seekTo_timeout);\r\n            IframeTube_player_seekTo_timeout = setTimeout(() => {\r\n                IframeTube_player_seekTo(time);\r\n            }, 100);\r\n            return;\r\n        }\r\n\r\n        // send the seek message to the embedded player\r\n        IframeTube_proxyPlayer.contentWindow.postMessage('IframeTube_seekTo_' + time, '*');\r\n    }\r\n\r\n\r\n    // enables the previous button when we are on a playlist\r\n    let IframeTube_player_enablePrevButton_timeout = false;\r\n    function IframeTube_player_enablePrevButton() {\r\n        // if the embedded player is not loaded yet, retry\r\n        if (!IframeTube_youtubePlayerLoaded) {\r\n            clearTimeout(IframeTube_player_enablePrevButton_timeout);\r\n            IframeTube_player_enablePrevButton_timeout = setTimeout(IframeTube_player_enablePrevButton, 100);\r\n            return;\r\n        }\r\n\r\n        // send the enable previous button message to the embedded player\r\n        IframeTube_proxyPlayer.contentWindow.postMessage('IframeTube_enablePrevButton', '*');\r\n    }\r\n\r\n    // disables the previous button when we are not on a playlist\r\n    let IframeTube_player_disablePrevButton_timeout = false;\r\n    function IframeTube_player_disablePrevButton() {\r\n        // if the embedded player is not loaded yet, retry\r\n        if (!IframeTube_youtubePlayerLoaded) {\r\n            clearTimeout(IframeTube_player_disablePrevButton_timeout);\r\n            IframeTube_player_disablePrevButton_timeout = setTimeout(IframeTube_player_disablePrevButton, 100);\r\n            return;\r\n        }\r\n        // send the disable previous button message to the embedded player\r\n        IframeTube_proxyPlayer.contentWindow.postMessage('IframeTube_disablePrevButton', '*');\r\n    }\r\n\r\n    // hides the proxy player or toggles PIP mode on home page\r\n    function IframeTube_HidePlayer() {\r\n        // if PIP is disabled\r\n        if (!IframeTube_pip) {\r\n            // remove PIP class if it exists\r\n            if (IframeTube_proxyWrapper.classList.contains('PIP')) {\r\n                IframeTube_proxyWrapper.classList.remove('PIP');\r\n            }\r\n            // hide the proxy wrapper\r\n            IframeTube_proxyWrapper.classList.add('IframeTube_hidden');\r\n            // stop the embedded player playback\r\n            IframeTube_player_stop();\r\n        }\r\n        // else, we are in PIP mode\r\n        else {\r\n            // remove the hidden class and add the PIP class\r\n            IframeTube_proxyWrapper.classList.remove('IframeTube_hidden');\r\n            IframeTube_proxyWrapper.classList.add('PIP');\r\n        }\r\n    }\r\n\r\n    // updates theater mode attribute, this is both used for language and because the theater button has two different tooltips (depending on the mode)\r\n    let IframeTube_updateTheaterAttributes_timeout = false;\r\n    function IframeTube_updateTheaterAttributes() {\r\n\r\n        // get the native button\r\n        let nativeButton = document.querySelector('#movie_player .ytp-size-button');\r\n        // if it exists and the embedded player has loaded\r\n        if (nativeButton && IframeTube_youtubePlayerLoaded) {\r\n            // get the tooltip title\r\n            let tooltipTitle = nativeButton.getAttribute('data-tooltip-title');\r\n            // send it to the embedded player\r\n            IframeTube_proxyPlayer.contentWindow.postMessage(\r\n                'IframeTube_theaterButtonAttribute_' + tooltipTitle,\r\n                '*'\r\n            );\r\n        }\r\n        // otherwise, the player is not loaded yet, retry again in 100ms\r\n        else {\r\n            clearTimeout(IframeTube_updateTheaterAttributes_timeout);\r\n            IframeTube_updateTheaterAttributes_timeout = setTimeout(IframeTube_updateTheaterAttributes, 100);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // update the theater icon, this is because the theater button has two different icons (depending on the mode)\r\n    let IframeTube_updateTheaterIcon_timeout = false;\r\n    function IframeTube_updateTheaterIcon(mode) {\r\n        let message = false;\r\n\r\n        // if we called the function with 'theater', set the message to theater\r\n        if (mode === 'theater') {\r\n            message = 'IframeTube_setTheaterIcon';\r\n        }\r\n\r\n        // if we called the function with 'default', set the message to default\r\n        else if (mode === 'default') {\r\n            message = 'IframeTube_setDefaultIcon';\r\n        }\r\n\r\n        // if no mode was provided, get the theater attribute from the native flexy and decide based off that\r\n        else if (!mode) {\r\n            let flexy = document.querySelector('ytd-watch-flexy');\r\n            if (flexy && flexy.hasAttribute('theater')) {\r\n                message = 'IframeTube_setTheaterIcon';\r\n            }\r\n            else {\r\n                message = 'IframeTube_setDefaultIcon';\r\n            }\r\n        }\r\n\r\n        // if the message exists and the embedded player is loaded, send the message to it\r\n        if (message && IframeTube_youtubePlayerLoaded) {\r\n            IframeTube_proxyPlayer.contentWindow.postMessage(\r\n                message,\r\n                '*'\r\n            );\r\n        }\r\n        // otherwise, retry in 100ms with the same arguments (mode)\r\n        else {\r\n            clearTimeout(IframeTube_updateTheaterIcon_timeout);\r\n            IframeTube_updateTheaterIcon_timeout = setTimeout(() => {\r\n                IframeTube_updateTheaterIcon(mode);\r\n            }, 100);\r\n        }\r\n    }\r\n\r\n    // inits the theater button on first load (the Youtube player takes a while to update the button, so we do it like this)\r\n    let IframeTube_initTheaterButton_timeout = false;\r\n    function IframeTube_initTheaterButton() {\r\n        let flexy = document.querySelector('ytd-watch-flexy');\r\n\r\n        // if the native flexy has the theater attribute, set the theater icon and copy attributes\r\n        if (flexy && flexy.hasAttribute('theater')) {\r\n            // wait for 100 ms to give the player time to set the correct icon and tooltip\r\n            setTimeout(() => {\r\n                IframeTube_updateTheaterAttributes();\r\n                IframeTube_updateTheaterIcon('theater');\r\n            }, 100);\r\n        }\r\n\r\n        // else, set the default icon and copy the tooltip\r\n        else if (flexy && !flexy.hasAttribute('theater')) {\r\n            // wait for 100 ms to give the player time to set the correct icon and tooltip\r\n            setTimeout(() => {\r\n                IframeTube_updateTheaterAttributes();\r\n                IframeTube_updateTheaterIcon('default');\r\n            }, 100);\r\n        }\r\n\r\n        // if the flexy has not loaded yet, retry in 100 ms\r\n        else {\r\n            clearTimeout(IframeTube_initTheaterButton_timeout);\r\n            IframeTube_initTheaterButton_timeout = setTimeout(IframeTube_initTheaterButton, 100);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // copy the native autoplay button attributes, we do this to get the attribute in the current language\r\n    let IframeTube_copyAutoPlayAttribute_timeout = false;\r\n    function IframeTube_copyAutoPlayAttribute() {\r\n\r\n        // get the native button\r\n        let nativeButton = document.querySelector('#movie_player .ytp-autonav-toggle-button');\r\n        // get the native’s button text (tooltip is stored here)\r\n        let nativeText = document.querySelector('.ytp-autonav-toggle');\r\n\r\n        // if they both exist, and the text has the 'aria-label' attribute\r\n        if (nativeButton && nativeText && nativeText.getAttribute('aria-label')) {\r\n            // init the texts as false\r\n            let enabledText = false;\r\n            let disabledText = false;\r\n\r\n            // if the button is disabled\r\n            if (nativeButton.getAttribute('aria-checked') === 'false') {\r\n                // click it, so it becomes enabled\r\n                nativeButton.click();\r\n            }\r\n\r\n            // sanity check to make sure it is enabled\r\n            if (nativeButton.getAttribute('aria-checked') === 'true') {\r\n                enabledText = nativeText.getAttribute('aria-label'); // set the enabled text to the current attribute\r\n                // click the button to disable it\r\n                nativeButton.click();\r\n            }\r\n\r\n            // wait for 50ms to make sure the button was switched to disabled\r\n            setTimeout(() => {\r\n                // sanity check to make sure it is disabled\r\n                if (nativeButton.getAttribute('aria-checked') === 'false') {\r\n                    disabledText = nativeText.getAttribute('aria-label'); // set the disabled text to the current attribute\r\n                }\r\n\r\n                // if both texsts exists\r\n                if (disabledText && enabledText) {\r\n                    // sent the post message to the embedded player with the texsts\r\n                    IframeTube_proxyPlayer.contentWindow.postMessage(\r\n                        'IframeTube_setAutoplayAttributes_' + enabledText + '|' + disabledText,\r\n                        '*'\r\n                    );\r\n                }\r\n            }, 50);\r\n        }\r\n        // otherwise, retry in 100 ms until the elements are found\r\n        else {\r\n            clearTimeout(IframeTube_copyAutoPlayAttribute_timeout);\r\n            IframeTube_copyAutoPlayAttribute_timeout = setTimeout(IframeTube_copyAutoPlayAttribute, 100);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // play the next video\r\n    function IframeTube_nextVideo() {\r\n        // if auto play is enabled\r\n        if (IframeTube_autoPlay === 'true') {\r\n            // trigger the 'next' shortcut\r\n            IframeTube_shortcut('next');\r\n        }\r\n\r\n        // else if playlist is enabled\r\n        else if (IframeTube_playlist) {\r\n            // trigger the 'next' shortcut as well\r\n            IframeTube_shortcut('next');\r\n        }\r\n        // otherwise, do not play the next video\r\n    }\r\n\r\n    // IMPORTANT: WHEN AN AD IS PLAYING ON A NON PLAYLIST VIEO, WE CANNOT GET THE ATTRIBUTES! PLEASE USE A COMBO OF IframeTube + other AdBlock (e.g. uBlock Origin) TO SKIP THE AD AND GET THE TOOLTIP IMMEDIATELY!\r\n    // if anyone has a different solution, please open a PR or an issue :) Only reliable methods will be pushed.\r\n\r\n    // get the preview of the next video\r\n    let IframeTube_nextVideoPreview_timeout = false;\r\n    function IframeTube_nextVideoPreview() {\r\n        // find the native 'next' button\r\n        let nativeButton = document.querySelector('#movie_player .ytp-next-button');\r\n        // if we found it\r\n        if (nativeButton) {\r\n            // get all the needed attributes\r\n            let shortcutTitle = nativeButton.getAttribute('data-tooltip-title'); // shortcut, e.g. NEXT (SHIFT+N)\r\n            let videoTitle = nativeButton.getAttribute('data-tooltip-text'); // video title\r\n            let videoThumbnail = nativeButton.getAttribute('data-preview'); // video thumbnail\r\n            // if they all exist, send them to the embedded player as a JSON (we do this, as people can put almost anything into the video title, and | would fail)\r\n            if (shortcutTitle && videoTitle && videoThumbnail) {\r\n                IframeTube_proxyPlayer.contentWindow.postMessage(\r\n                    'IframeTube_nextVideoPreview_' + JSON.stringify({ shortcutTitle, videoTitle, videoThumbnail }),\r\n                    '*'\r\n                );\r\n            }\r\n            // otherwise, retry in 100ms until they all exist\r\n            else {\r\n                clearTimeout(IframeTube_nextVideoPreview_timeout);\r\n                IframeTube_nextVideoPreview_timeout = setTimeout(IframeTube_nextVideoPreview, 100);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    // remove the attributes of the next button for each new video (this is because it takes a while for the button to appear, and by doing this we trigger our timeout in IframeTube_nextVideoPreview)\r\n    function IframeTube_resetNextButton() {\r\n        let nativeButton = document.querySelector('#movie_player .ytp-next-button');\r\n        // if the embedded player is loaded, and the native button exists\r\n        if (IframeTube_youtubePlayerLoaded && nativeButton) {\r\n            // remove all of these attributes\r\n            nativeButton.removeAttribute('data-tooltip-title');\r\n            nativeButton.removeAttribute('data-tooltip-text');\r\n            nativeButton.removeAttribute('data-preview');\r\n        }\r\n    }\r\n\r\n    // play the previous video\r\n    function IframeTube_prevVideo() {\r\n        // only trigger the shortcut if we are on a playlist\r\n        if (IframeTube_playlist) {\r\n            IframeTube_shortcut('previous');\r\n        }\r\n    }\r\n\r\n    // get the preview of the previous video\r\n    let IframeTube_prevVideoPreview_timeout = false;\r\n    function IframeTube_prevVideoPreview() {\r\n        // find the 'previous' button\r\n        let nativeButton = document.querySelector('#movie_player .ytp-prev-button');\r\n        // if we found it\r\n        if (nativeButton) {\r\n            // get all the needed attributes\r\n            let shortcutTitle = nativeButton.getAttribute('data-tooltip-title'); // shortcut, e.g. PREVIOUS (SHIFT+P)\r\n            let videoTitle = nativeButton.getAttribute('data-tooltip-text'); // video title\r\n            let videoThumbnail = nativeButton.getAttribute('data-preview'); // video thumbnail\r\n            // if they all exist, send them to the embedded player as a JSON (we do this, as people can put almost anything into the video title, and | would fail)\r\n            if (shortcutTitle && videoTitle && videoThumbnail) {\r\n                IframeTube_proxyPlayer.contentWindow.postMessage(\r\n                    'IframeTube_prevVideoPreview_' + JSON.stringify({ shortcutTitle, videoTitle, videoThumbnail }),\r\n                    '*'\r\n                );\r\n            }\r\n            // otherwise, retry in 100ms until they all exist\r\n            else {\r\n                clearTimeout(IframeTube_prevVideoPreview_timeout);\r\n                IframeTube_prevVideoPreview_timeout = setTimeout(IframeTube_prevVideoPreview, 100);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    // remove the attributes of the previopus button for each new video (this is because it takes a while for the button to appear, and by doing this we trigger our timeout in IframeTube_prevVideoPreview)\r\n    function IframeTube_resetPrevButton() {\r\n        let nativeButton = document.querySelector('#movie_player .ytp-prev-button');\r\n        // if the embedded player is loaded, and the native button exists\r\n        if (IframeTube_youtubePlayerLoaded && nativeButton) {\r\n            // remove all of these attributes\r\n            nativeButton.removeAttribute('data-tooltip-title');\r\n            nativeButton.removeAttribute('data-tooltip-text');\r\n            nativeButton.removeAttribute('data-preview');\r\n        }\r\n    }\r\n\r\n    // supports timestamp links in the description and comments\r\n    function IframeTube_timestampLinks() {\r\n        let links = document.querySelectorAll('.comment-content a, #description a, ytm-expandable-video-description-body-renderer a, ytd-comments .yt-core-attributed-string a');\r\n        // loop through them\r\n        links.forEach(link => {\r\n            // prevent adding multiple listeners\r\n            if (link.classList.contains('IframeTube_timestampLink')) {\r\n                return;\r\n            }\r\n\r\n            // if the link href contains a timestamp (e.g. ?t=123 or &t=123)\r\n            if (link.href && (link.href.indexOf('?t=') !== -1 || link.href.indexOf('&t=') !== -1)) {\r\n\r\n                // add a class to indicate we added the listener\r\n                link.classList.add('IframeTube_timestampLink');\r\n                // add a click event listener\r\n                link.addEventListener('click', (event) => {\r\n\r\n                    // prevent the default browser and Youtube action\r\n                    event.preventDefault();\r\n                    event.stopImmediatePropagation();\r\n\r\n                    // extract the timestamp manually\r\n                    let time = false;\r\n                    let url = new URL(link.href);\r\n                    if (url.searchParams.get('t')) {\r\n                        time = url.searchParams.get('t');\r\n                    }\r\n\r\n                    // if we found a timestamp, seek to it\r\n                    if (time) {\r\n                        IframeTube_player_seekTo(time);\r\n                        // scrolls up to the player\r\n                        window.scrollTo({\r\n                            top: 0,\r\n                            behavior: 'smooth'\r\n                        });\r\n                    }\r\n                }, true);\r\n\r\n                link.addEventListener('mousedown', (event) => {\r\n                    // prevent the default browser and Youtube action\r\n                    event.preventDefault();\r\n                    event.stopImmediatePropagation();\r\n                }, true);\r\n\r\n                link.addEventListener('mouseup', (event) => {\r\n                    // prevent the default browser and Youtube action\r\n                    event.preventDefault();\r\n                    event.stopImmediatePropagation();\r\n                }, true);\r\n            }\r\n        });\r\n    }\r\n\r\n    // add shortcuts to the page (we do this so if the user is triggering a shortcut while not focused in the embedded player, it still triggers correctly)\r\n    function IframeTube_addShorcuts() {\r\n        document.addEventListener('keydown', IframeTube_shortcutsHandler);\r\n        document.addEventListener('keyup', IframeTube_shortcutsHandler);\r\n    }\r\n\r\n    // handle all the shortcuts\r\n    function IframeTube_shortcutsHandler(event) {\r\n        // if we are holding the altkey, ctrlkey, metakey, or we are NOT on the watch page, do not proceed\r\n        if (event.altKey || event.ctrlKey || event.metaKey || !IframeTube_watchPage()) {\r\n            return;\r\n        }\r\n\r\n        // define all the shortcuts we send to the player\r\n        let shortcuts = [\r\n            ' ',\r\n            'k',\r\n            'j',\r\n            'l',\r\n            'm',\r\n            'f',\r\n            'i',\r\n            'c',\r\n            'o',\r\n            't',\r\n            'arrowleft',\r\n            'arrowright',\r\n            'arrowup',\r\n            'arrowdown',\r\n            'home',\r\n            'end',\r\n            '0',\r\n            '1',\r\n            '2',\r\n            '3',\r\n            '4',\r\n            '5',\r\n            '6',\r\n            '7',\r\n            '8',\r\n            '9',\r\n        ];\r\n\r\n        // if the shortcut is not trusted (triggered programmatically) OR it is not included in the allowed shortcuts, do not proceed\r\n        if (!event.isTrusted || !shortcuts.includes(event.key.toLowerCase())) {\r\n            return;\r\n        }\r\n\r\n        // if we are inside a text field, do not proceed\r\n        let isTextField = event.target;\r\n        if (\r\n            isTextField &&\r\n            (\r\n                isTextField.tagName.toLowerCase().indexOf('input') !== -1 ||\r\n                isTextField.tagName.toLowerCase().indexOf('label') !== -1 ||\r\n                isTextField.tagName.toLowerCase().indexOf('select') !== -1 ||\r\n                isTextField.tagName.toLowerCase().indexOf('textarea') !== -1 ||\r\n                isTextField.tagName.toLowerCase().indexOf('fieldset') !== -1 ||\r\n                isTextField.tagName.toLowerCase().indexOf('legend') !== -1 ||\r\n                isTextField.tagName.toLowerCase().indexOf('datalist') !== -1 ||\r\n                isTextField.tagName.toLowerCase().indexOf('output') !== -1 ||\r\n                isTextField.tagName.toLowerCase().indexOf('option') !== -1 ||\r\n                isTextField.tagName.toLowerCase().indexOf('optgroup') !== -1\r\n            )\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        // prevent the default browser action, and the default Youtube shortcut\r\n        event.preventDefault();\r\n        event.stopImmediatePropagation();\r\n        // send the shortcut to the embedded player\r\n        IframeTube_proxyPlayer.contentWindow.postMessage(\r\n            'IframeTube_shortcut_' + event.type + '_' + event.key + '_' + event.shiftKey + '_' + event.keyCode,\r\n            '*'\r\n        );\r\n    }\r\n\r\n    // detect if the url has changed, and load/hide the video\r\n    function IframeTube_repeater() {\r\n\r\n        // last and current urls\r\n        let lastUrl = IframeTube_lastURL;\r\n        let currentUrl = window.location.href;\r\n\r\n        // simplify them to compare\r\n        if (lastUrl) {\r\n            lastUrl = lastUrl.replace(/([#&]index=.*$)|(#.*$)/, '');\r\n        }\r\n        if (currentUrl) {\r\n            currentUrl = currentUrl.replace(/([#&]index=.*$)|(#.*$)/, '');\r\n        }\r\n\r\n        // if they DO NOT equal\r\n        if (lastUrl !== currentUrl) {\r\n\r\n            // update the global variable of lastURL\r\n            IframeTube_lastURL = window.location.href;\r\n\r\n            // if we are on a watch page\r\n            if (IframeTube_watchPage()) {\r\n                // get the current video id\r\n                let currentVideoId = IframeTube_extractParams('v');\r\n\r\n                // additional safety check to prevent double embedding and allow to play the next video if the user has used the back/forward button\r\n                if (!(lastUrl && !IframeTube_isWatchUrl(lastUrl)) && !IframeTube_historyPopped && currentVideoId === IframeTube_lastVideoId) {\r\n                    return;\r\n                }\r\n\r\n                // update the variable\r\n                IframeTube_lastVideoId = currentVideoId;\r\n                // embed/load the video\r\n                IframeTube_embedVideo();\r\n                // indicate that we are not using the back/forward buttons\r\n                IframeTube_historyPopped = false;\r\n            }\r\n            // if we are not watching a video, hide the player\r\n            else {\r\n                IframeTube_HidePlayer();\r\n            }\r\n        }\r\n\r\n        // regardless of urls, if we are on a watchpage, position the proxy and support timestamp links very 100ms\r\n        if (IframeTube_watchPage()) {\r\n            IframeTube_positionProxy();\r\n            IframeTube_timestampLinks();\r\n        }\r\n    }\r\n\r\n    // checks if we are using the back/forward buttons\r\n    function IframeTube_checkPopstate() {\r\n        if (!IframeTube_historyPopped) {\r\n            IframeTube_historyPopped = true;\r\n            return;\r\n        }\r\n    }\r\n\r\n    // listen for messages sent from the iframes\r\n    function IframeTube_listenForMessages(event) {\r\n        // if the message is not valid, do not proceed\r\n        if (typeof event.data !== 'string') {\r\n            return;\r\n        }\r\n\r\n        // if the proxy iframe has loaded, set a flag to indicate that\r\n        else if (event.data === 'IframeTube_proxyLoaded') {\r\n            IframeTube_proxyLoaded = true;\r\n        }\r\n\r\n        // if the embedded Youtube iframe has loaded, set a flag to indicate that and also show the proxy player with the video in it\r\n        else if (event.data === 'IframeTube_youtubePlayerLoaded') {\r\n            IframeTube_youtubePlayerLoaded = true;\r\n            IframeTube_proxyPlayer.style.display = 'block';\r\n        }\r\n\r\n        // theater has been set to on/off\r\n        else if (event.data === 'IframeTube_theater') {\r\n\r\n            // trigger the shortcut\r\n            IframeTube_shortcut('t');\r\n\r\n            // wait for 150 ms for the native Youtube player to update, then update the theater attribute and icon\r\n            setTimeout(() => {\r\n                IframeTube_updateTheaterAttributes();\r\n                IframeTube_updateTheaterIcon();\r\n            }, 150);\r\n\r\n            // if we are in full screen, exit it immediately\r\n            if (document.fullscreenElement) {\r\n                document.exitFullscreen();\r\n            }\r\n        }\r\n\r\n        // enables autoplay\r\n        else if (event.data === 'IframeTube_enableAutoplay') {\r\n            IframeTube_autoPlay = 'true'\r\n            IframeTube_setCookie('IframeTube_autoplay', IframeTube_autoPlay);\r\n        }\r\n\r\n        // disables autoplay\r\n        else if (event.data === 'IframeTube_disableAutoplay') {\r\n            IframeTube_autoPlay = 'false'\r\n            IframeTube_setCookie('IframeTube_autoplay', IframeTube_autoPlay);\r\n        }\r\n\r\n        // embed video has ended\r\n        else if (event.data === 'IframeTube_video_ended') {\r\n            // play the next video\r\n            IframeTube_nextVideo();\r\n        }\r\n\r\n        // next video (triggered by the next button or shift+n shortcut)\r\n        else if (event.data === 'IframeTube_nextVideo') {\r\n            // play the next video\r\n            IframeTube_shortcut('next');\r\n        }\r\n\r\n        // request the next video preview\r\n        else if (event.data === 'IframeTube_nextVideo_preview') {\r\n            IframeTube_nextVideoPreview();\r\n        }\r\n\r\n        // previous video (triggered by the previous button or shift+p shortcut)\r\n        else if (event.data === 'IframeTube_previousVideo') {\r\n            IframeTube_prevVideo();\r\n        }\r\n\r\n        // request the previous video preview if we are on a playlist\r\n        else if (event.data === 'IframeTube_previousVideo_preview') {\r\n            if (IframeTube_playlist) {\r\n                IframeTube_prevVideoPreview();\r\n            }\r\n        }\r\n\r\n        // pip has been entered\r\n        else if (event.data === 'IframeTube_enteredPip') {\r\n            IframeTube_pip = true;\r\n        }\r\n\r\n        // pip has been exited\r\n        else if (event.data === 'IframeTube_leftPip') {\r\n            IframeTube_pip = false;\r\n            // if we are not on a watch page, hide the player\r\n            if (!IframeTube_watchPage()) {\r\n                IframeTube_HidePlayer();\r\n            }\r\n        }\r\n\r\n        // sync the main player’s time with the embedded player’s\r\n        // this is to keep video recommendations and watch history accurate\r\n        // this can break if you use the IframeTube + other AdBlock combo (if the other adblock gets detected)\r\n        else if (event.data.startsWith('IframeTube_syncPlayer')) {\r\n\r\n            // if we are watching a video, and an ad is NOT playing\r\n            if (IframeTube_watchPage() && !IframeTube_WatchingAd()) {\r\n\r\n                // refetch the iframe api\r\n                IframeTube_iframe_api = document.getElementById('movie_player');\r\n\r\n                // get the native plaer\r\n                let nativePlayer = document.querySelector('#movie_player video');\r\n\r\n                // get the sync time from the post message\r\n                let syncTime = parseFloat(event.data.split('IframeTube_syncPlayer_')[1]);\r\n\r\n                // if the iframe api exists, and has the seek, getcurrent time feature AND the native player exists\r\n                if (IframeTube_iframe_api && IframeTube_iframe_api.seekTo && IframeTube_iframe_api.getCurrentTime && nativePlayer) {\r\n\r\n                    // get the current time of the native player\r\n                    let currentTime = IframeTube_iframe_api.getCurrentTime();\r\n                    // round the current time\r\n                    currentTime = Math.round(currentTime);\r\n\r\n                    // if the current rounded time does not equal the embedded video time\r\n                    if (currentTime !== syncTime) {\r\n\r\n                        // set the syncing flag to true\r\n                        IframeTube_syncing = true;\r\n\r\n                        // seek the native player to the embedded player’s time\r\n                        IframeTube_iframe_api.seekTo(syncTime, true);\r\n                        // play the native player’s video\r\n                        IframeTube_iframe_api.playVideo();\r\n\r\n                        // mute it via the iframe api, and set the volume to 0 (prevent audio leaks)\r\n                        IframeTube_iframe_api.mute();\r\n                        IframeTube_iframe_api.setVolume(0);\r\n\r\n                        // also mute it via html, and set the volume to 0\r\n                        nativePlayer.muted = true;\r\n                        nativePlayer.volume = 0;\r\n\r\n\r\n                        // after 500 ms (half a second), pause the video and stop syncing\r\n                        setTimeout(() => {\r\n                            IframeTube_iframe_api.pauseVideo();\r\n                            IframeTube_syncing = false;\r\n                        }, 500);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // get the video link from the embedded player’s end screen\r\n        else if (event.data.startsWith('IframeTube_endScreen_')) {\r\n            let url = event.data.replace('IframeTube_endScreen_', ''); // video url\r\n            let videoId = url.split('v=')[1].split('&')[0]; // video id\r\n\r\n            // if we are on a playlist, set the current url to the video url (only reliable way, playlist do not dissapear when faking it)\r\n            if (IframeTube_playlist) {\r\n                window.location.href = url;\r\n            }\r\n\r\n            // if we are going to a playlist, also set the current url to the video url\r\n            else if (url.includes('list=')) {\r\n                window.location.href = url;\r\n            }\r\n\r\n            // otherwise, if we are not on a playlist, and we are going to a normal video, fake an SPA navigation and do NOT reload the page (faster video loading)\r\n            else {\r\n                // loads the video by id first\r\n                IframeTube_iframe_api = document.getElementById('movie_player');\r\n                IframeTube_iframe_api.loadVideoById(videoId);\r\n\r\n                // creates the yt-navigate event with the video id\r\n                let navEvent = new CustomEvent('yt-navigate', {\r\n                    detail: {\r\n                        endpoint: {\r\n                            watchEndpoint: { videoId: videoId },\r\n                            commandMetadata: {\r\n                                webCommandMetadata: {\r\n                                    url: `/watch?v=${videoId}`,\r\n                                    webPageType: 'WEB_PAGE_TYPE_WATCH'\r\n                                }\r\n                            }\r\n                        }\r\n                    },\r\n                    bubbles: true,\r\n                    cancelable: true,\r\n                    composed: true\r\n                });\r\n\r\n                // dispatches the fake event\r\n                document.querySelector('ytd-app').dispatchEvent(navEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    // inits IframeTube\r\n    function IframeTube_init() {\r\n        IframeTube_hidePageAdsEtc();\r\n        IframeTube_muteAndPauseVideos();\r\n        setInterval(IframeTube_muteAndPauseVideos, 100);\r\n        IframeTube_proxyIframe();\r\n        IframeTube_addShorcuts();\r\n        IframeTube_setLowestQuality();\r\n        IframeTube_fixShortsQuality();\r\n        IframeTube_initTheaterButton();\r\n\r\n        // adds an event listener for yt-navigate (fires whenever you navigate to a new page on Youtube)\r\n        document.addEventListener('yt-navigate', () => {\r\n            // if we are on a shorts page, and last URL was NOT a short\r\n            if (IframeTube_shortsWatchPage() && !IframeTube_lastURL.includes('/shorts/')) {\r\n                // fix shorts qualityy\r\n                IframeTube_fixShortsQuality();\r\n            }\r\n            // otherwise, if we are on a wath page\r\n            else if (IframeTube_watchPage()) {\r\n                // reset the next button’s attributes\r\n                IframeTube_resetNextButton();\r\n                // if we are on a playlist, also reset the previous button’s attributes\r\n                if (IframeTube_playlist) {\r\n                    IframeTube_resetPrevButton();\r\n                }\r\n            }\r\n            // otherwise, if we are on any other page\r\n            else {\r\n                // mute and pause the miniplayer \r\n                IframeTube_mute_miniplayer();\r\n            }\r\n        });\r\n\r\n        // add a listener for messages from iframes\r\n        window.addEventListener('message', IframeTube_listenForMessages);\r\n\r\n        // add a listener for the back/forward browser buttons\r\n        window.addEventListener('popstate', IframeTube_checkPopstate);\r\n    }\r\n\r\n    // calls the init function\r\n    IframeTube_init();\r\n\r\n    // end of IIFE\r\n})();"],"names":["IframeTube_setCookie","name","value","IframeTube_readCookie","nameEQ","cookies","c","cookie","IframeTube_extractParams","param","IframeTube_watchPage","url","params","queryParts","i","keyValue","pathParts","IframeTube_shortsWatchPage","IframeTube_isWatchUrl","IframeTube_WatchingAd","adElement","adPlaying","IframeTube_shortcut","key","actualKey","code","shift","keyCode","which","focusEvent","keydownEvent","beforeInputEvent","keypressEvent","inputEvent","changeEvent","keyupEvent","IframeTube_proxyPlayer","IframeTube_proxyWrapper","IframeTube_pip","IframeTube_proxyLoaded","IframeTube_youtubePlayerLoaded","IframeTube_iframe_api","IframeTube_shorts_api","IframeTube_qualityListenerAdded","IframeTube_lastURL","IframeTube_lastVideoId","IframeTube_historyPopped","IframeTube_embeddedVideo","IframeTube_syncing","IframeTube_playlist","IframeTube_autoPlay","IframeTube_hidePageAdsEtc","style","IframeTube_muteAndPauseVideos","video","IframeTube_mute_miniplayer","miniplayer","IframeTube_proxyIframe_timeout","IframeTube_proxyIframe","proxyWrapper","proxy","IframeTube_repeater","IframeTube_positionProxy","players","nativePlayer","rect","IframeTube_embedVideo_timeout","IframeTube_embedVideo","videoId","IframeTube_player_enablePrevButton","IframeTube_player_disablePrevButton","startTimeNumber","tParam","startTime","IframeTube_language","IframeTube_copyAutoPlayAttribute","IframeTube_syncStart","IframeTube_syncStart_timeout","currentTime","IframeTube_player_seekTo","IframeTube_setLowestQuality_timeout","IframeTube_setLowestQuality","availableQualities","lowestQuality","IframeTube_fixShortsQuality_timeout","IframeTube_fixShortsQuality","highestQuality","IframeTube_player_stop_timeout","IframeTube_player_stop","IframeTube_player_seekTo_timeout","time","IframeTube_player_enablePrevButton_timeout","IframeTube_player_disablePrevButton_timeout","IframeTube_HidePlayer","IframeTube_updateTheaterAttributes_timeout","IframeTube_updateTheaterAttributes","nativeButton","tooltipTitle","IframeTube_updateTheaterIcon_timeout","IframeTube_updateTheaterIcon","mode","message","flexy","IframeTube_initTheaterButton_timeout","IframeTube_initTheaterButton","IframeTube_copyAutoPlayAttribute_timeout","nativeText","enabledText","disabledText","IframeTube_nextVideo","IframeTube_nextVideoPreview_timeout","IframeTube_nextVideoPreview","shortcutTitle","videoTitle","videoThumbnail","IframeTube_resetNextButton","IframeTube_prevVideo","IframeTube_prevVideoPreview_timeout","IframeTube_prevVideoPreview","IframeTube_resetPrevButton","IframeTube_timestampLinks","link","event","IframeTube_addShorcuts","IframeTube_shortcutsHandler","shortcuts","isTextField","lastUrl","currentUrl","currentVideoId","IframeTube_checkPopstate","IframeTube_listenForMessages","syncTime","navEvent","IframeTube_init"],"mappings":"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"}